---
title: boj 16948 데스나이트 python
description: boj problem 16948 solved by python
date: '2022-03-09T17:29:48+09:00'
tags: [PS, BFS]
---

### 접근
1. 이제 bfs문제는 너무 웰노운이 되어버려서 그냥 가볍게 풀고싶을때 푼다.

이동할 수 없는 경우에 -1을 출력하는 출력 조건을 못봐서 한번 틀렸는데, 풀이가 어렵지는 않았다.

```python
import sys
from collections import deque
input = sys.stdin.readline

move = [(-2, -1), (-2, 1), (0, -2), (0, 2), (2, -1), (2, 1)]


def is_valid(x, y):
    return 0 <= x < n and 0 <= y < n


def bfs(start):
    queue = deque([start])

    while queue:
        x, y = queue.popleft()
        if x == r2 and y == c2:
            return visited[x][y]
        for m_x, m_y in move:
            new_x, new_y = x+m_x, y+m_y
            if is_valid(new_x, new_y) and visited[new_x][new_y] == 0:
                visited[new_x][new_y] = visited[x][y] + 1
                queue.append((new_x, new_y))
    return -1


n = int(input())
r1, c1, r2, c2 = map(int, input().split())
visited = [[0 for _ in range(n)] for _ in range(n)]
print(bfs((r1, c1)))
```

